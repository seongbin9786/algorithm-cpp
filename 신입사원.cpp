#include <iostream>

/*
    [Silver 1]
    신입 사원
    https://www.acmicpc.net/problem/1946
    
    다른 모든 지원자와 비교했을 때, 적어도 하나가 떨어지지 않는 자만 선발
    그냥 브루트포스 아니냐? 이게 왜 그리디 문제임?

    사람이 100,000 이라, 모두 비교하기는 좀 망했음. (최대 2,000,000까지 가능. TC가 20개 까지니까)
    - 참고로 (1,1)이면 걔만 뽑을 수 있음

    일단 넣고 보자는 마인드?

    - 정렬 해야 할까? 자꾸 정렬이 생각이 난다.
    - 서류로 오름차순 정렬 후 1등 뽑는다.
    - 면접으로 오름차순 정렬 후 1등 뽑는다.
    - 다음 원소를 봤을 때, 1등보다 둘 다 못하면 탈락
        - 아니면 추가 (여기서 끝이 아님.)
        - 1등이 꼭 좋은 게 아님 - 둘의 합이 가장 낮은 순서로 정렬해도 좋을 듯
        - 

    [idea]
    서류로 정렬하고, 면접으로 2차 정렬함
    => 서류 1등이 나옴
    => 2등..3등.. 나올텐데, 이 때 면접 점수가 선발 인원의 최저점(최대등수)보다 작으면(등수가 크면) out
    => 
 
    T <= 20
    N <= 100,000

    (ex)
    2   (T=2)

    5   (N=1)
    3 2 
    1 4 1등이니까 선택
    4 1 1등이니까 선택
    2 3 
    5 5 

    => [1] [4] 선택 (하나가 1등인거 추첨)
    => [4] [1] 선택 (하나가 1등인거 추첨)
    => [4] [4] 가 min임 일단 (둘 다 4보다 작아야함) - 일단 추가
    => [2] [3] 선택
    => 여기서 (2,3)으로 뭘 해야 하며,       ===> (2,3)에 안 지는 애를 뽑아야 함. (1,4)나 (4,1)보단 좋다. | 걍 List로 해도 되겠지만 너무 느릴듯
                                           ===> 둘 중 highest가 낮은 애를 놓는 게 맞다. 뭔지 알지? => [2, 3] 으로 놓는다.
    => (3,2)를 선택할 수 있는가?            ===> 


    7   (N=2)
    3 6
    7 3 
    4 2 1등보다 서류좋음 (아니 이게 아니라니깐? )
    1 4 1등
    5 7 
    2 5
    6 1 1등

    --출력--
    4
    3
*/
using namespace std;

int _main()
{
    int T, N;
    cin >> T >> N;
    cout << mul(b) << "\n";
    return 0;
}
