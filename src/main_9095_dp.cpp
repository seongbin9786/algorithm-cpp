#include <stdio.h>
#include <vector>
#include <algorithm>
#include "../include/debugopen.hpp"

using namespace std;

/*

    문풀에서 이렇게 막혀도 되나
    문제를 풀 단계가 맞는지 생각해봐야?
    곧장 생각이 잘 나지 않을 때에는 실제 예제 데이터를 간단하게 시작해서 다양하게 실제로 노가다하자.
    노가다가 중요하다. 머갈로 하면 효율이 떨어질 쯔음엔 case 노가다로 전환하자

    9095
    1, 2, 3 더하기

    1초, 512MB 제한

    정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
    0 < n < 11
    덧셈이지만 단항으로 구성될 수도 있다. (cnt(1) = 1)

    (ex) n=4
    // 순서가 의미 있음을 알 수 있다.
    (아마 DP로 풀리게 하려면 이렇게 구성을 해야 하는듯?)
    1+1+1+1
    1+1+2
    1+2+1
    2+1+1
    1+3
    2+2
    3+1

    [풀이 시도 1]
    n=4 이면
    cnt(X, 1) + cnt(X, 2) + cnt(X, 3) + cnt(X, 1, 2) + cnt(X, 1, 3) + cnt(X, 2, 3)
    으로 놓으면 되지 않을까? 아.. 아닌가? 가변 변수 좀 그렇네
    이 순열을 어떻게 구할까...
    모르겠다
    n=4
    1, 2로 표현하려면
    1로 표현하는 방법=1
    2로 표현하는 방법=1 (4%2=0)
    1,2로 표현하는 방법(1, 2 중 하나만 쓰는 것 X)
     =
        즉
        2 자리와 1자리로 나뉜다.
        -----
        1,1,2
        1,2,1
        2,1,1

        ==> n=4 에서 2가 들어갈 수 있는 개수는 [1, (n % 2 == 0 ? n/2-1 : n/2)] 이다.
        ==> 그렇다면 배열할 수 있는 경우의 수: (1의 개수) + (2의 개수)

            ===> 땡!
            ===> n=6 일 때
            2 2 1 1
            2 1 1 1 1
            이 가능하다.
            이 경우의 문제점:
                - 2끼리, 1끼리 순서가 바뀌는 것은 count되지 않아야 한다.
                - 2 2 1 1
                - 1 2 2 1
                - 1 1 2 2
                - 2 1 1 2
                - 1 2 1 2 <--- 이게 없는데요~^^
                - 2 1 2 1 <--- 얘도 없네욧 ^^%
                ====> 어라? (1의 개수) + (2의 개수)가 성립하긴 한다 ... XXXXX [ N O P E ]



    [풀이 시도 2]
    개수 세는 과정이 합집합이므로 이번엔 min 함수가 아닌 덧셈으로 처리해야 한다.
    따라서 아래의 식을 사용해야 할 것 같다.
    DP의 본질은 문제를 쪼개는 것이므로, 쪼개는 것에는 성공한 것 같다:

        memo[X] = cnt(X, 1) + cnt(X, 2) + cnt(X, 3) (여기는 계산이 없다. 0..3 이다.)
                + cnt(X, 1, 2) + cnt(X, 1, 3) + cnt(X, 2, 3) // 이 때 두 수를 모두 써야 함.
                + cnt(X, 1, 2, 3) // 이 때 세 수를 모두 써야 함.

            => 이 때 cnt 함수는 3개를 만들어야 할듯 ㅋㅋㅋ

    각 cnt를 어떻게 계산할지 생각해보기 전에,
    어떻게 DP를 쓸 지 생각하는 게 우선인 듯하다.
    즉 어떻게 더 작은 cnt를 큰 cnt에 대응시키는가를 도출해야 할 것 같다.

    실제 코드에서는 그냥 X % 3 과 X < 3 등을 체크해 0을 반환하도록 하자
    cnt(1) = 1
    cnt(2) = cnt(1) + cnt(2)
           = 1(1,1) + 0
    cnt(3) = cnt(1) + cnt(2) + cnt(3) + cnt(1,2)
           = 1 + 0 + 1 + 2(1,2 | 2,1)
           = 4
    cnt(4) = cnt(1) + cnt(2) + cnt(1,2) + cnt(1,3)
           = 1 + 1 + 3(211|121|112) + 2(31|13)
           = 7
    cnt(5) = 아뉘 쑤바
    이게 아니잖아요

    이건 그냥 계산이잖아
    이건 DP가 아니다

    [풀이 시도 3]
    memo[X] = memo[X...] + memo[X....] + k 이런 식으로 식을 도출해야 한다.
    ㅇㅋ 가보자

        memo[3] =
            // 아래 주석은 3->4 기준으로 쓰여진 것임)
            1+1+1   +1 (얘는 의미 없음)
            1+2     +1 // 양 옆이라고 생각하지 말자. 문제가 복잡해진다. (얘는 양 옆에 가능. 현재 2칸이니까.)
            2+1     +1 // 상동

            // 새거
            3

        memo[4] = (memo[3]) =>
            (위에서 +1만 더한 거임)
            1+1+1+1
            1+2+1
            2+1+1
            3+1

            // 위에서 빠진 조합
            // 둘 다 +1을 앞에서 하는 case
            // cnt(1)은 어차피 앞에서 더해도 동일함
            //
            1+1+2
            1+2+1 // 이 경우는 앞에 +1을 하면 위와 중복되는데 어떻게 함?
            1+3

            (4여서 여긴 새로 생긴 부분)
            (2,2)와 (1,3)이 새로 생겼다.
            2+2
            1+3 // 얘는 없음.
            3+1 // 얘는 있는데

        memo[5] =
            // 아래의 패턴에 +1만 더해주면 된다.
            // 위의 패턴에 +1만 수행한 것
            1+1+1+1+1
            1+1+2+1
            1+2+1+1
            2+1+1+1
            2+2+1   // 2+2+1 의 경우 경우의 수가 3가지가 된다 (221, 212, 122)
                    // 그냥 1만 더하는 걸로 퉁칠 순 없다.
            1+3+1
            3+1+1
            // 113 은 어디갔을까. (얘는 나올 수가 없다.) (1,3), (3,1)은 나올 수 있지만.

            (5여서 새로 생긴 패턴)
            (위에서 없는 것만 생각해본다면)

            // 순열은 쉽게 구할 수 있으니.
            (2,3)이 새로 생겼다.
            (2,2,1)이 새로 생겼다.
            (1,1,3)이 새로 생겼다.
            2+3
            3+2
            2+2+1 // 위에거랑 중복이다
            1+2+2
            2+1+2
            1+1+3
            얘 밖에 없는 거 같은뎅

*/
void precalc_9095(int X)
{
}

int main_9095()
{
    int N;
    READ_TXT("input.txt", "rt", stdin);
    scanf("%d", &N);
    // memo[1] = 0;
    vector<int> v(N);
    for (int i = 0; i < N; i++)
    {
        scanf("%d", &v[i]);
    }
    return 0;
}
