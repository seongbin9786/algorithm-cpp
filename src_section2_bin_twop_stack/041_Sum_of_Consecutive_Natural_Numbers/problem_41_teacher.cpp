#include "problem_41.hpp"

/*
유형: 구현
[풀이 전략]

----
내 방법은 브루트포스인데,

N=15
seq_len=2
=> 길이가 2인 수열이 존재하는지 확인한다.
=> 각 원소에 각각 [1,2] 를 더한다.
=> 일단 N에서 더해줄 모든 값[1+2]을 빼주고, 15-[1,2] = 12 이고
=> 나머지[12]에서 원소의개수[2]를 나눠준다. 12/2 = 6 이고
=> 계산 결과 중 나머지가 0인 경우 수열이 성립한다.
=> [6+1], [6+2] => 7, 8 => 7+8=15 [v]
=> 나머지가 0이 아닌 경우는 성립하지 않는다.
----
=> 브루트포스인 건 마찬가진데 이 방법은 실패하는 case가 거의 상수시간이라 O(n)이고
=> 내 알고리즘은 O(n^2)이므로 성능 차이는 매우 크다.

=> 이 방법도 "2개 이상의" 라는 조건을 통해 직관적으로 떠올릴 만한 것 같다.
=> base 값이 있고 거기서 각 값에 +i 씩 더해지는 조건이니까
=> base*i + (0+...+i) 이런식으로도 생각할 수 있었을듯

더 좋은 방법이니 알아둬야겠다.

*/
void problem_41()
{
    int i, j, k, n, sum, cnt = 0, len = 0;
    READ_TXT("./resources/input41.txt", "rt", stdin);
    scanf("%d", &n);
    if (n % 2 == 1)
        i = (n + 1) / 2;
    else
        i = n / 2;
    std::vector<int> buf(i); // i개 해놓으면 걱정 없지. 좀 더 좋은 계산법이 있을지도
    // 배열에 넣으면 좀 쉽겠지.. 근데 초기화 하기가 너무 귀찮다.
    while (i > 0)
    {
        sum = 0;
        for (j = i; j > 0; j--)
        {
            sum += j;
            buf[len++] = j;
            if (sum == n)
            {
                for (k = len - 1; k > 0; k--) // 일부러 buf[0] 출력 X
                    printf("%d + ", buf[k]);
                printf("%d = %d\n", buf[0], sum);
                len = 0;
                cnt++; // 다음 수열 찾으러 감
                break;
            }
            else if (sum > n) // 초과했으면 실패한 수열
            {
                len = 0; // 굳이 배열을 초기화할 필요는 없다. len까지 덮어쓰면 됨.
                break;
            }
            if (j == 1) // 이제부터 수열의 합은 무조건 sum < n. 여기서 탈출.
            {
                printf("%d\n", cnt);
                return;
            }
        }
        i--;
    }
}
