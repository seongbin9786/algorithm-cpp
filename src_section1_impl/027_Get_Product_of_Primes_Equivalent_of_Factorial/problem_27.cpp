#include "problem_27.hpp"

/*
유형: 구현
[풀이 전략]
흠 N이 너무 크다.
일단 팩토리얼 계산 하는 것부터 좀 그렇다.
팩토리얼을 계산하고 소인수 분해를 하기보다,
N!을 갈 때 까지 숫자를 각각 소인수 분해하면 되겠다. (음 뭐지 바로 발상이 되네)

소수의 배열을 쓰면 될 것 같다. 근데 대응되는 index는 어떻게 구할까?
=> 미리 최대 크기의 소수를 구한다. (X)
=> N 범위가 어차피 1,000 밖에 안되므로 그냥 소수 자체 값을 idx로 쓰고, 0이 아닌 소수 개수를 모조리 출력하면 된다.
(ex) 53! 이면 max 소수도 53일 것이다.
(ex) 1000! 이면 max 소수도 1,000일 것이다.
char 배열 (1바이트 사용 목적) 천 개 쯤이야 괜찮다.

---
5개의 wrong answer..
흠..
아 53! = 이런식으로 출력해야 되는구나;;

---
그래도 안 되는데.. 진짜 뭐지?
결국 TC 1을 봤고 100!을 출력시켜봤으나 매우 정상이었음.
그래서 pause 넣고 window에서 돌려보니 마지막에 쓰레기 값이 뜨고 있었음.
아, 배열 범위는 n 인데 접근 idx를 <= n 까지 놨었던 거임 (애초에 범위를 n으로 잡으면 안됐음. 개수가 아니라 숫자를 바로 idx로 쓰는거여서.)
배열 범위 하 ㅋㅋ 리눅스에서 안 떠서 잘 되고 있었던 건줄 알았음.
앞으로는 터미널 믿지 말고 좀 더 index 생각 잘 하자 ^^
*/
void problem_27()
{
    int i, j, n, cur;
    READ_TXT("./resources/input27.txt", "rt", stdin);
    scanf("%d", &n);
    std::vector<int> primes(n + 1); // 소수 idx를 위해서. 0으로 초기화되기도 하고.
    for (i = 2; i <= n; i++)
    {
        cur = i;
        for (j = 2; cur > 1 && j <= i; j++)
        {
            if (cur % j == 0)
            {
                primes[j]++;
                cur /= j;
                j--; // 여러 번 수행할 수도 있어야 하므로.
            }
        }
    }
    printf("%d! = ", n);
    // <= n 때문에 웬 쓰레기 값이 출력되고 있었던 것..
    // 몇 번을 돌렸는데 여기선 확인을 못 했었네
    // 애초에 n+1 개만큼 생성하는게 맞음. 하...
    for (i = 2; i <= n; i++)
        if (primes[i] != 0)
            printf("%d ", primes[i]);

    // 고마운 놈이다. 버그 발견할 수 있었음.
    // windows에서만 쓰레기값이 떴는데 <---- 중요
    // 리눅스에서는 그동안 0으로 인식돼서 운이 좋았던 거였는듯
    // 이라고 생각했으나, 한 20번 했는데도 쓰레기 값이 뜨지 않았음
    // 이유는 모르겠다. WSL + g++ 이라서 그런가? g++이 출력할 때 뭘 해주는건지 모르겠다.
    // system("pause");
}
