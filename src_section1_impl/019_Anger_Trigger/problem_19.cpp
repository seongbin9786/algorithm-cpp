#include "problem_19.hpp"

/*
유형: 구현
[풀이 전략]
max를 구해야 되나?
뒤에서부터 구해서, max가 바뀌는 시점마다 cnt++ 하면 될 거 같은데?
=> 그런데 이렇게 하려면 모두 읽어야 함. 처리가 귀찮다.
=> 스트리밍으로 문제 해결할 수는 없을까?

흠 전체 학생 수를 알아야 반복을 어디까지 할 지 결정할 수 있을 것 같은데?
=> 아 문제 이해를 잘못 했던 거였음. 그냥 한 줄로만 앉음 ㅇㅇ.
=> 그럼 원래 풀려던 대로 풀면 끝나네

----
=> TC 2, 4, 5 Wrong Answer
뭐가 문제일까?

(1). 앞 사람과 키가 같으면 max로 인정 X (이게 답 기준이네. 상식적으로 키가 겹치면 안 보이는건데 말이다.)

(2). TC를 생각할 시간이 필요하다. (흠!)
=> 결국 문제를 의심하고 TC 2를 까봤는데 답은 3이고 내 답은 4였다.
=> 맨 마지막이 문제인 것 같더라.
=> solved. 이건 스스로 해결하려면 어떻게 해야 됐을까? 무슨 TC를 생각해야 됐을까?
=> [n-1] > [n-2] && [n-3] < [n-1]인 경우를 생각해봤어야 함
3
2 1 3
=> 0

하지만 원래 내거였다면 => 2 (1>0 이므로 max=1, 2>1 이므로 max=2)
=> 애초에 알고리즘이 잘못 됐었음.

작은 잘못된 가정 때문에 문제 풀이는 전체가 실패해버림. (어디가 잘못인지도 모른 채)
이건 작은 단위의 함수를 테스트하면서 문제 해결의 단위를 작게 만들면 쉬워질 거라고 생각함.
- 단 이번 경우는 함수로 분리할 정도로 큰 것도 아니었고 동시에 한 함수에서 할 수 있어서 불가능한듯

이번 문제의 경우도 처음에 입력을 의심했었는데 그런 거 필요 없이 바로 로직 테스트를 할 수 있었다면...

C++ Test Runner 찾아봐야겠다.
*/
void problem_19()
{
    int i, n, max, cnt = 0;
    int arr[100];

    READ_TXT("./resources/input19.txt", "rt", stdin);
    scanf("%d", &n);
    for (i = 0; i < n; i++)
        scanf("%d", arr + i);
    // 마지막 case: i = 1 일 때.
    // n=1 일 때도 실행 안 돼서 good.
    max = arr[n - 1]; // 0으로 초기화하면 맨 마지막 요소가 고려가 안 됨
    for (i = n - 1; i > 0; i--)
    {
        // i-1부터 시작하는 셈이니까 맨 마지막 원소가 max인 경우는 알아서 skip
        if (arr[i - 1] > arr[i] && arr[i - 1] > max)
        {
            debug("current: arr[%d]: %d > arr[%d]: %d, max: %d\n", i - 1, arr[i - 1], i, arr[i], max);
            max = arr[i - 1];
            cnt++;
        }
    }
    printf("%d\n", cnt);
    // return; // 이거 없으면 프로그램이 출력을 안 하고 Time Exceeded가 뜨는데 뭐지..? (가끔씩 그러면 그냥 다시 키는걸로...)
}
