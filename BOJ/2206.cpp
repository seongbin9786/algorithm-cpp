#include <stdio.h>
#include <tuple>
#include <queue>
#include "../include/debugopen.hpp"

using namespace std;

/*
    벽 부수고 이동하기
    2206

    맵:NxM
    - 0: 이동 가능
    - 1: 벽

    목표:
    - (1, 1)에서 (N, M)까지 최소 개수의 칸(시작, 끝 칸도 포함)을 통과해 이동.
    - 만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면,
      벽을 한 개 까지 부수고 이동하여도 된다.

    - 이동 범위: 상하좌우
    - 최단 <거리> 출력 필요 - 불가능 시 -1 출력.

    첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다.
    다음 N개의 줄에 M개의 숫자로 맵이 주어진다.
    (1, 1)과 (N, M)은 항상 0이라고 가정하자.

    (ex) a=15
    6 4
    0100
    1110
    1000
    0000
    0111
    0000

    (ex) a=-1
    4 4
    0111
    1111
    1111
    1110

    -----
    1. BFS로 탐색하는 게 편할듯.
        - Undirected, Unweighted의 경우 BFS만으로 최소 경로를 찾을 수 있다고 한다.
            - 최단 경로는 BFS or 다익스트라이므로 이 둘 중 고민하자.
            - 다익스트라는 기억이 안나므로 BFS를 사용하자.
    2. 벽을 부수는 행위에 대해 생각해보자
        - 언제 필요할까?
            1) 1번 예시처럼 처음부터 탈출이 불가능할 때 - 참고로 부수기는 1회만 가능하다.
            2) 그냥 상하좌우 + 부수는 상하좌우 까지 고려하는 건?
                - 경우의 수가 늘어난다.
                - 방향이 8개라고 보면 될듯
                - 블럭은 최대 10만개(1000^2), BFS의 시간복잡도= O(10만 + 8*10만) = O(90만)
                - 시간은 충분하다.
            3) 먼저 부숴야 하나, 다 돌고 부숴야 하나? 상관이 없나?
                - 단지 먼저 도착하기만 하면 그게 최단 경로이므로 상관이 없을듯?
                - why?
                    - 블록을 단 한 번만 부술 수 있기 때문임.

    3. 경로 횟수를 어떻게 세지?
        - pair<y, x> 대신 struct로 가야할듯 { y, x, sumOfVisits, broke };

    4. 최단 경로를 찾으려면 가능한 모든 경로를 탐색해야 하는 건가?
        - 노노. BFS로 탐색하면 최단이라고 함.
        - '벽 부수기'가 있는데 정말 최단인가?
        - (ex)
            000000010
            011111110
            010000010
            010101010
            010101110
            000101000

            1번 뚫는 방식에 따라 횟수가 달라지는 case
            - best: 14
            - worse: 20 | 20

            - 자동으로 14번만에 갈까? 큐니까 가능할까?
            - 큐니까 가능할듯? 어차피 각 경로를 한 칸씩 차례로 동시에(not parallel) 진행하기 때문에,
              최단 경로가 있으면 걔가 먼저 도착할 것.

    ~~
    메모리 초과 = ?
    192MB 제한

    ~~
    "틀렸습니다." Case 일 때 이해가 안 됨.

    ~~
    배운 점: short를 쓸 때 %hd를 써야 함. %d는 작동하지 않음.
*/
/*
    부수고 가는 시점이 여러 가지인데, 각 경우마다 visited가 달라야 할듯?
    visited를 list로 저장할까? parent로?
    visited를 체크하는 시간은 충분할듯. 10만개인데 2초니까.
    노노. 매번 10만개를 체크할 순 없을 것 같음. 결국 map으로 가야될듯?
    처음 생성한 vector는 broke하지 않으면 계속 공유된다.
    - vector 방식은 별로인 것 같음.

    부수기를 고려하지 않았을 때, BFS 특성상 한 번 지나간 길을 돌아오지 않음. 다른 방향으로 진행할 뿐임.

    부순 후의 경로로 진행할 때, 최단 경로에 속한 지점이 기존에 방문한 지점일 수 있음.
    - 이 경우에는 visited 배열을 격리해야 함.

    부순 시점이 다른 경우가 있을 수 있음
    - 초기에 최단 경로 지점을 굉장히 빠르게 부순 경우와, 나중에 끝끝내 부순 경우가 있을 수 있음
        - 두 경로가 겹치지 않을까?
            - 해당 지점을 기준으로 가장 빠른 경로를 이은 게 최단 경로. BFS는 이 경로를 반드시 찾을 수 있다.

    만약 visited를 공유하지 않는다면, 벽을 이미 부순 경우 뒤로 갈 수도 있음.
    => 원칙적으론 갈 수 없는 게 맞는데, 가도 상관은 없다. 거기로 가면 어차피 최단 경로가 아니게 된다.
    => 경로의 개수를 세는 등의 문제라면 필터링하는 게 맞음.

*/

short dx2206[4] = {1, -1, 0, 0};
short dy2206[4] = {0, 0, -1, 1}; // 동서남북으로 가자

typedef tuple<short,
              short,
              int, // 방문 횟수는 10만도 되므로, 32767까지인 short를 쓸 수 없음.
              bool>
    unit2206;
queue<unit2206> Q2206;

bool visited2206[1001][1001][2] = {false};
bool map2206[1001][1001] = {false};
short N2206, M2206, i2206, j2206, nx2206, ny2206;
int answer2206 = -1, nv2206;

void findShortestPath()
{
    while (!Q2206.empty())
    {
        auto [y, x, blocksVisited, broke] = Q2206.front();
        Q2206.pop();

        // 기 방문 장소에 방문 시 다른 작업 취소
        // 이게 없어도 찾긴 하겠지만 더 비효율적일듯.
        if (visited2206[y][x][broke])
            continue;

        visited2206[y][x][broke] = true;
        nv2206 = blocksVisited + 1;

        // 종료 조건
        // (0,0) ~ (N-1, M-1)
        if (y == N2206 - 1 && x == M2206 - 1)
        {
            // 마지막 방문도 추가되므로 +1 해줘야 함.
            answer2206 = blocksVisited;
            return;
        }

        // 4방향 수행
        for (i2206 = 0; i2206 < 4; i2206++)
        {
            ny = y + dy2206[i2206];
            nx = x + dx2206[i2206];

            // 맵 범위 제한 확인
            if (ny < 0 || ny >= N2206 || nx < 0 || nx >= M2206)
                continue;

            // 일반 진입
            if (!map2206[ny][nx] && !visited2206[ny][nx][0])
                Q2206.push({ny, nx, nv2206, broke}); // 일반 진입이라고 false로 바뀌면 안 됨.

            // 부수기 삽입 수행 후 진입
            if (!broke && map2206[ny][nx] && !visited2206[ny][nx][1])
                Q2206.push({ny, nx, nv2206, true});
        }
    }
    answer2206 = -1; // 도달하지 못하고 큐가 빔.
}

int main()
{
    READ_TXT("input.txt", "rt", stdin);
    scanf("%hd %hd", &N2206, &M2206);
    char buf[1001];
    for (i2206 = 0; i2206 < N2206; i2206++)
    {
        scanf("%s", buf); // 문자열로 입력받아야.
        for (j2206 = 0; j2206 < M2206; j2206++)
            if (buf[j2206] - '0' > 0)
                map2206[i2206][j2206] = true;
    }
    Q2206.push({0, 0, 1, false});
    findShortestPath();
    printf("%d\n", answer2206);
    return 0;
}
