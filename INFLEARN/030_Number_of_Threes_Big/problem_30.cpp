#include "problem_30.hpp"

/*
유형: 구현
(N <= 1,000,000,000)
[풀이 전략]
일단 그냥 구하는 건 좀 쉬우니까 (%로 자리수별로 하면 되니까) 29번을 스킵했는데
아마 거기서 필요한 통찰력이 있을까? 아마 없을듯
=> 일단 계산 수를 줄이기 위해 [012]에서 이용했던 개수 계산을 해야 될 것 같다. 아니, 그냥 동일한 문제 같은데?
=> 복습용인가? 개꿀..

기본적인 3의 개수: 
-> 3은 각 자리수별로 한 번만 등장한다. 즉 기본적으로 9번 등장한다. (일의 자리 제외)
-> 일의 자리: 03, 13, 23, 43, 53, 63, 73, 83, 93 이 있다. => 10개
-> 십의 자리: 030, 130, 230, 330, 430, 530, 630, 730, 830, 930 이 있다. => 10개
-> 백의 자리: 0300, 1300, 2300, 3300, 4300, 5300, 6300, 7300, 8300, 9300 이 있다. => 10개

특수한 3의 개수:
-> 3x의 경우 계속 3이다. (ex) 30~39 => +10
-> 3xx의 경우도 계속 3이다. (ex) 300 ~ 399 => +100
-> 3xxx => 3000 ~ 3999 => +1000

따라서:
-> 일의 자리: 10개 맞음 (영의 자리는 없으니 끝임.)
-> 십의 자리: 10개 - 1개(30) + 10개[30~39] => 19개.
-> 백의 자리: 10개 - 1개(300) + 100개[300~399] => 109개.
-> 천의 자리: 10개 - 1개(3000) + 1000개[3000~3999] => 1009개.

일정값으로 구분하는 경우:
(ex) 15
c = 15 % 10 = 5
-> 03 가능 (if c >= 3) res++;

c = 1 % 10 = 1
-> 13 가능 여부는 이전 자릿수에 달려있음. prev >= 3 여야 가능함.
-> if (prev >= 3) res++;

---

(ex) 100, prev=0
c = 10 % 10 = 0
if (prev >= 3) // X
else res++;
res = 10 -> 10이니까 3을 취해야 하므로. 

c = 1 % 10 = 0
if (prev >= 3) // X
else 
res = 100 -> 19개 먹어야 함. (단 )


이 문제가 12번과 다른 이유:
-> 3천이라는 경곗값 때문에.


자리수별로 커져가면서 계속 더해주면 될 것 같다.

*/
void problem_30()
{
    int n, c, d = 10, res = 0;
    int prev = 0; // 초기 prev는 쓸모 없음.
    READ_TXT("./resources/input30.txt", "rt", stdin);
    scanf("%d", &n);
    // 이걸 기본값으로 시작하자.
    prev = n % 10;
    n /= 10;
    // 대충 이런 '느낌'이었는데...
    while (res + d < n)
    {
        c = n % 10;
        if (prev >= 3)
        {
            // 가능함.
        }
        res = res * c + d; // 이런거였나?
        prev = c;
        d *= 10;
        n /= 10;
    }
    printf("%d\n", res);
}
