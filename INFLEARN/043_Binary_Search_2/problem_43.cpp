#include "problem_43.hpp"

/*
유형: 구현
[풀이 전략]
[N <= 1,000] [num_of_DVD <= N]
[lengths...]

- 주어진 DVD에 가장 큰 용량을 설정하려 한다.
- 순서를 바꿀 수 없음. 그렇다고 오름차순 정렬돼있는 것도 아님..
- 곡이 넘칠 순 없지만 모자라는건 됨.
- DVD의 길이는 10,000을 넘지 않음 (뭔 상관인지..)

(긴 시간 생각해봤는데도 아예 모르겠다.)

---

(일단 skip)
강의 내용 대충 봤는데 <결정 알고리즘> 이라고 한다.
결정 알고리즘이란 답을 미리 정해놓고 확인하는 알고리즘이라고 한다. (무슨 서술이 그리디 급으로 추상적임;)
즉, [결정] 단계 -> [확인] 단계 로 구분해서 구현하면 쉬울듯.

1. 조건: 숫자 개수 = N , DVD 개수 = D
2. 조건: 전체 값(a[0] ~ a[N-1])을 더한 값 = M (ex) 45
3. 결정: [1...M] 을 이분 탐색 한 값 = S (ex) 22
4. 확인: 수열을 순회하면서 순차적으로 더했을 때 D개 이하의 그룹으로 S 값 이하로 저장해 나눌 수 있는지 확인. O(N)
        => 가능하면 이번 S가 가능한 것이므로 answer=S (ex) answer=22
5. 확인: S = 이분 탐색해서 계속 이동한다. 
        => (ex) 45 -> 22(1..45) -> 11(1..22) -> 17(12..22) -> 14(12..16) -> ~~ 
        => 이런 식으로 O(log 2 M) 번 반복 (worst case 100%)
        => 종료 시 주어진 <M, D> 에 대해 min(S)를 보장한다.
*/
void problem_43()
{
    int i, n, dvd, sum = 0;
    READ_TXT("./resources/input43.txt", "rt", stdin);
    scanf("%d %d", &n, &dvd);
    std::vector<int> arr(n);
    for (i = 0; i < n; i++)
        scanf("%d", &arr[i]);
    printf("%d\n", sum / dvd); // 개 짜증나려고 한다 ㅋㅋ
}
